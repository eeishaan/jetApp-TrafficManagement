# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: rib_service.proto

import sys
_b=sys.version_info[0]<3 and (lambda x:x) or (lambda x:x.encode('latin1'))
from google.protobuf.internal import enum_type_wrapper
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database
from google.protobuf import descriptor_pb2
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


import jnx_addr_pb2 as jnx__addr__pb2
import prpd_common_pb2 as prpd__common__pb2


DESCRIPTOR = _descriptor.FileDescriptor(
  name='rib_service.proto',
  package='routing',
  syntax='proto3',
  serialized_pb=_b('\n\x11rib_service.proto\x12\x07routing\x1a\x0ejnx_addr.proto\x1a\x11prpd_common.proto\"\x8d\x01\n\x10RouteMatchFields\x12,\n\x0b\x64\x65st_prefix\x18\x01 \x01(\x0b\x32\x17.routing.NetworkAddress\x12\x17\n\x0f\x64\x65st_prefix_len\x18\x02 \x01(\r\x12\"\n\x05table\x18\x03 \x01(\x0b\x32\x13.routing.RouteTable\x12\x0e\n\x06\x63ookie\x18\x04 \x01(\x04\"\x88\x01\n\x0cRouteGateway\x12\x30\n\x0fgateway_address\x18\x01 \x01(\x0b\x32\x17.routing.NetworkAddress\x12\x16\n\x0einterface_name\x18\x02 \x01(\t\x12.\n\rlocal_address\x18\x03 \x01(\x0b\x32\x17.routing.NetworkAddress\"7\n\x0cRouteNexthop\x12\'\n\x08gateways\x18\x01 \x03(\x0b\x32\x15.routing.RouteGateway\"\\\n\nRouteEntry\x12&\n\x03key\x18\x01 \x01(\x0b\x32\x19.routing.RouteMatchFields\x12&\n\x07nexthop\x18\x02 \x01(\x0b\x32\x15.routing.RouteNexthop\"9\n\x12RouteUpdateRequest\x12#\n\x06routes\x18\x01 \x03(\x0b\x32\x13.routing.RouteEntry\"=\n\x12RouteRemoveRequest\x12\'\n\x04keys\x18\x01 \x03(\x0b\x32\x19.routing.RouteMatchFields\"\xfd\x01\n\x0fRouteGetRequest\x12&\n\x03key\x18\x01 \x01(\x0b\x32\x19.routing.RouteMatchFields\x12+\n\nmatch_type\x18\x02 \x01(\x0e\x32\x17.routing.RouteMatchType\x12\x13\n\x0b\x61\x63tive_only\x18\x03 \x01(\x08\x12\x34\n\x14reply_address_format\x18\x04 \x01(\x0e\x32\x16.jnxBase.AddressFormat\x12\x35\n\x12reply_table_format\x18\x05 \x01(\x0e\x32\x19.routing.RouteTableFormat\x12\x13\n\x0broute_count\x18\x06 \x01(\r\"X\n\x0eRouteOperReply\x12(\n\x06status\x18\x01 \x01(\x0e\x32\x18.routing.RouteOperStatus\x12\x1c\n\x14operations_completed\x18\x02 \x01(\r\"^\n\rRouteGetReply\x12(\n\x06status\x18\x01 \x01(\x0e\x32\x18.routing.RouteOperStatus\x12#\n\x06routes\x18\x02 \x03(\x0b\x32\x13.routing.RouteEntry*:\n\x0eRouteMatchType\x12\x08\n\x04\x42\x45ST\x10\x00\x12\t\n\x05\x45XACT\x10\x01\x12\x13\n\x0f\x45XACT_OR_LONGER\x10\x02*\x83\x04\n\x0fRouteOperStatus\x12\x0b\n\x07SUCCESS\x10\x00\x12\x12\n\x0eINTERNAL_ERROR\x10\x01\x12\x13\n\x0fNOT_INITIALIZED\x10\x02\x12\t\n\x05NO_OP\x10\x03\x12\x10\n\x0cTOO_MANY_OPS\x10\x04\x12\x11\n\rTABLE_INVALID\x10\x05\x12\x13\n\x0fTABLE_NOT_READY\x10\x06\x12\x12\n\x0ePREFIX_INVALID\x10\x07\x12\x18\n\x14PREFIX_LEN_TOO_SHORT\x10\x08\x12\x17\n\x13PREFIX_LEN_TOO_LONG\x10\t\x12\x13\n\x0fGATEWAY_INVALID\x10\n\x12\x13\n\x0fNEXTHOP_INVALID\x10\x0b\x12\x1b\n\x17NEXTHOP_ADDRESS_INVALID\x10\x0c\x12\x18\n\x14NEXTHOP_LIMIT_EXCEED\x10\r\x12\x10\n\x0cROUTE_EXISTS\x10\x0e\x12\x13\n\x0fROUTE_NOT_FOUND\x10\x0f\x12\x14\n\x10PROTOCOL_INVALID\x10\x10\x12\x14\n\x10ROUTE_ADD_FAILED\x10\x11\x12\r\n\tNOT_READY\x10\x12\x12\r\n\tTRY_AGAIN\x10\x13\x12\x17\n\x13ROUTE_COUNT_INVALID\x10\x14\x12\x17\n\x13REQUEST_UNSUPPORTED\x10\x15\x12\x13\n\x0fREQUEST_INVALID\x10\x16\x12\x15\n\x11INTERFACE_INVALID\x10\x17\x32\xe0\x02\n\x03Rib\x12\x42\n\x08RouteAdd\x12\x1b.routing.RouteUpdateRequest\x1a\x17.routing.RouteOperReply\"\x00\x12\x45\n\x0bRouteModify\x12\x1b.routing.RouteUpdateRequest\x1a\x17.routing.RouteOperReply\"\x00\x12\x45\n\x0bRouteUpdate\x12\x1b.routing.RouteUpdateRequest\x1a\x17.routing.RouteOperReply\"\x00\x12\x45\n\x0bRouteRemove\x12\x1b.routing.RouteRemoveRequest\x1a\x17.routing.RouteOperReply\"\x00\x12@\n\x08RouteGet\x12\x18.routing.RouteGetRequest\x1a\x16.routing.RouteGetReply\"\x00\x30\x01\x62\x06proto3')
  ,
  dependencies=[jnx__addr__pb2.DESCRIPTOR,prpd__common__pb2.DESCRIPTOR,])
_sym_db.RegisterFileDescriptor(DESCRIPTOR)

_ROUTEMATCHTYPE = _descriptor.EnumDescriptor(
  name='RouteMatchType',
  full_name='routing.RouteMatchType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    _descriptor.EnumValueDescriptor(
      name='BEST', index=0, number=0,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='EXACT', index=1, number=1,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='EXACT_OR_LONGER', index=2, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=1063,
  serialized_end=1121,
)
_sym_db.RegisterEnumDescriptor(_ROUTEMATCHTYPE)

RouteMatchType = enum_type_wrapper.EnumTypeWrapper(_ROUTEMATCHTYPE)
_ROUTEOPERSTATUS = _descriptor.EnumDescriptor(
  name='RouteOperStatus',
  full_name='routing.RouteOperStatus',
  filename=None,
  file=DESCRIPTOR,
  values=[
    _descriptor.EnumValueDescriptor(
      name='SUCCESS', index=0, number=0,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='INTERNAL_ERROR', index=1, number=1,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='NOT_INITIALIZED', index=2, number=2,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='NO_OP', index=3, number=3,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='TOO_MANY_OPS', index=4, number=4,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='TABLE_INVALID', index=5, number=5,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='TABLE_NOT_READY', index=6, number=6,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='PREFIX_INVALID', index=7, number=7,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='PREFIX_LEN_TOO_SHORT', index=8, number=8,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='PREFIX_LEN_TOO_LONG', index=9, number=9,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='GATEWAY_INVALID', index=10, number=10,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='NEXTHOP_INVALID', index=11, number=11,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='NEXTHOP_ADDRESS_INVALID', index=12, number=12,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='NEXTHOP_LIMIT_EXCEED', index=13, number=13,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='ROUTE_EXISTS', index=14, number=14,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='ROUTE_NOT_FOUND', index=15, number=15,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='PROTOCOL_INVALID', index=16, number=16,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='ROUTE_ADD_FAILED', index=17, number=17,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='NOT_READY', index=18, number=18,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='TRY_AGAIN', index=19, number=19,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='ROUTE_COUNT_INVALID', index=20, number=20,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='REQUEST_UNSUPPORTED', index=21, number=21,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='REQUEST_INVALID', index=22, number=22,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='INTERFACE_INVALID', index=23, number=23,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=1124,
  serialized_end=1639,
)
_sym_db.RegisterEnumDescriptor(_ROUTEOPERSTATUS)

RouteOperStatus = enum_type_wrapper.EnumTypeWrapper(_ROUTEOPERSTATUS)
BEST = 0
EXACT = 1
EXACT_OR_LONGER = 2
SUCCESS = 0
INTERNAL_ERROR = 1
NOT_INITIALIZED = 2
NO_OP = 3
TOO_MANY_OPS = 4
TABLE_INVALID = 5
TABLE_NOT_READY = 6
PREFIX_INVALID = 7
PREFIX_LEN_TOO_SHORT = 8
PREFIX_LEN_TOO_LONG = 9
GATEWAY_INVALID = 10
NEXTHOP_INVALID = 11
NEXTHOP_ADDRESS_INVALID = 12
NEXTHOP_LIMIT_EXCEED = 13
ROUTE_EXISTS = 14
ROUTE_NOT_FOUND = 15
PROTOCOL_INVALID = 16
ROUTE_ADD_FAILED = 17
NOT_READY = 18
TRY_AGAIN = 19
ROUTE_COUNT_INVALID = 20
REQUEST_UNSUPPORTED = 21
REQUEST_INVALID = 22
INTERFACE_INVALID = 23



_ROUTEMATCHFIELDS = _descriptor.Descriptor(
  name='RouteMatchFields',
  full_name='routing.RouteMatchFields',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='dest_prefix', full_name='routing.RouteMatchFields.dest_prefix', index=0,
      number=1, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='dest_prefix_len', full_name='routing.RouteMatchFields.dest_prefix_len', index=1,
      number=2, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='table', full_name='routing.RouteMatchFields.table', index=2,
      number=3, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='cookie', full_name='routing.RouteMatchFields.cookie', index=3,
      number=4, type=4, cpp_type=4, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=66,
  serialized_end=207,
)


_ROUTEGATEWAY = _descriptor.Descriptor(
  name='RouteGateway',
  full_name='routing.RouteGateway',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='gateway_address', full_name='routing.RouteGateway.gateway_address', index=0,
      number=1, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='interface_name', full_name='routing.RouteGateway.interface_name', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=_b("").decode('utf-8'),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='local_address', full_name='routing.RouteGateway.local_address', index=2,
      number=3, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=210,
  serialized_end=346,
)


_ROUTENEXTHOP = _descriptor.Descriptor(
  name='RouteNexthop',
  full_name='routing.RouteNexthop',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='gateways', full_name='routing.RouteNexthop.gateways', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=348,
  serialized_end=403,
)


_ROUTEENTRY = _descriptor.Descriptor(
  name='RouteEntry',
  full_name='routing.RouteEntry',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='key', full_name='routing.RouteEntry.key', index=0,
      number=1, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='nexthop', full_name='routing.RouteEntry.nexthop', index=1,
      number=2, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=405,
  serialized_end=497,
)


_ROUTEUPDATEREQUEST = _descriptor.Descriptor(
  name='RouteUpdateRequest',
  full_name='routing.RouteUpdateRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='routes', full_name='routing.RouteUpdateRequest.routes', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=499,
  serialized_end=556,
)


_ROUTEREMOVEREQUEST = _descriptor.Descriptor(
  name='RouteRemoveRequest',
  full_name='routing.RouteRemoveRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='keys', full_name='routing.RouteRemoveRequest.keys', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=558,
  serialized_end=619,
)


_ROUTEGETREQUEST = _descriptor.Descriptor(
  name='RouteGetRequest',
  full_name='routing.RouteGetRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='key', full_name='routing.RouteGetRequest.key', index=0,
      number=1, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='match_type', full_name='routing.RouteGetRequest.match_type', index=1,
      number=2, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='active_only', full_name='routing.RouteGetRequest.active_only', index=2,
      number=3, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='reply_address_format', full_name='routing.RouteGetRequest.reply_address_format', index=3,
      number=4, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='reply_table_format', full_name='routing.RouteGetRequest.reply_table_format', index=4,
      number=5, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='route_count', full_name='routing.RouteGetRequest.route_count', index=5,
      number=6, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=622,
  serialized_end=875,
)


_ROUTEOPERREPLY = _descriptor.Descriptor(
  name='RouteOperReply',
  full_name='routing.RouteOperReply',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='status', full_name='routing.RouteOperReply.status', index=0,
      number=1, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='operations_completed', full_name='routing.RouteOperReply.operations_completed', index=1,
      number=2, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=877,
  serialized_end=965,
)


_ROUTEGETREPLY = _descriptor.Descriptor(
  name='RouteGetReply',
  full_name='routing.RouteGetReply',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='status', full_name='routing.RouteGetReply.status', index=0,
      number=1, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='routes', full_name='routing.RouteGetReply.routes', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=967,
  serialized_end=1061,
)

_ROUTEMATCHFIELDS.fields_by_name['dest_prefix'].message_type = prpd__common__pb2._NETWORKADDRESS
_ROUTEMATCHFIELDS.fields_by_name['table'].message_type = prpd__common__pb2._ROUTETABLE
_ROUTEGATEWAY.fields_by_name['gateway_address'].message_type = prpd__common__pb2._NETWORKADDRESS
_ROUTEGATEWAY.fields_by_name['local_address'].message_type = prpd__common__pb2._NETWORKADDRESS
_ROUTENEXTHOP.fields_by_name['gateways'].message_type = _ROUTEGATEWAY
_ROUTEENTRY.fields_by_name['key'].message_type = _ROUTEMATCHFIELDS
_ROUTEENTRY.fields_by_name['nexthop'].message_type = _ROUTENEXTHOP
_ROUTEUPDATEREQUEST.fields_by_name['routes'].message_type = _ROUTEENTRY
_ROUTEREMOVEREQUEST.fields_by_name['keys'].message_type = _ROUTEMATCHFIELDS
_ROUTEGETREQUEST.fields_by_name['key'].message_type = _ROUTEMATCHFIELDS
_ROUTEGETREQUEST.fields_by_name['match_type'].enum_type = _ROUTEMATCHTYPE
_ROUTEGETREQUEST.fields_by_name['reply_address_format'].enum_type = jnx__addr__pb2._ADDRESSFORMAT
_ROUTEGETREQUEST.fields_by_name['reply_table_format'].enum_type = prpd__common__pb2._ROUTETABLEFORMAT
_ROUTEOPERREPLY.fields_by_name['status'].enum_type = _ROUTEOPERSTATUS
_ROUTEGETREPLY.fields_by_name['status'].enum_type = _ROUTEOPERSTATUS
_ROUTEGETREPLY.fields_by_name['routes'].message_type = _ROUTEENTRY
DESCRIPTOR.message_types_by_name['RouteMatchFields'] = _ROUTEMATCHFIELDS
DESCRIPTOR.message_types_by_name['RouteGateway'] = _ROUTEGATEWAY
DESCRIPTOR.message_types_by_name['RouteNexthop'] = _ROUTENEXTHOP
DESCRIPTOR.message_types_by_name['RouteEntry'] = _ROUTEENTRY
DESCRIPTOR.message_types_by_name['RouteUpdateRequest'] = _ROUTEUPDATEREQUEST
DESCRIPTOR.message_types_by_name['RouteRemoveRequest'] = _ROUTEREMOVEREQUEST
DESCRIPTOR.message_types_by_name['RouteGetRequest'] = _ROUTEGETREQUEST
DESCRIPTOR.message_types_by_name['RouteOperReply'] = _ROUTEOPERREPLY
DESCRIPTOR.message_types_by_name['RouteGetReply'] = _ROUTEGETREPLY
DESCRIPTOR.enum_types_by_name['RouteMatchType'] = _ROUTEMATCHTYPE
DESCRIPTOR.enum_types_by_name['RouteOperStatus'] = _ROUTEOPERSTATUS

RouteMatchFields = _reflection.GeneratedProtocolMessageType('RouteMatchFields', (_message.Message,), dict(
  DESCRIPTOR = _ROUTEMATCHFIELDS,
  __module__ = 'rib_service_pb2'
  # @@protoc_insertion_point(class_scope:routing.RouteMatchFields)
  ))
_sym_db.RegisterMessage(RouteMatchFields)

RouteGateway = _reflection.GeneratedProtocolMessageType('RouteGateway', (_message.Message,), dict(
  DESCRIPTOR = _ROUTEGATEWAY,
  __module__ = 'rib_service_pb2'
  # @@protoc_insertion_point(class_scope:routing.RouteGateway)
  ))
_sym_db.RegisterMessage(RouteGateway)

RouteNexthop = _reflection.GeneratedProtocolMessageType('RouteNexthop', (_message.Message,), dict(
  DESCRIPTOR = _ROUTENEXTHOP,
  __module__ = 'rib_service_pb2'
  # @@protoc_insertion_point(class_scope:routing.RouteNexthop)
  ))
_sym_db.RegisterMessage(RouteNexthop)

RouteEntry = _reflection.GeneratedProtocolMessageType('RouteEntry', (_message.Message,), dict(
  DESCRIPTOR = _ROUTEENTRY,
  __module__ = 'rib_service_pb2'
  # @@protoc_insertion_point(class_scope:routing.RouteEntry)
  ))
_sym_db.RegisterMessage(RouteEntry)

RouteUpdateRequest = _reflection.GeneratedProtocolMessageType('RouteUpdateRequest', (_message.Message,), dict(
  DESCRIPTOR = _ROUTEUPDATEREQUEST,
  __module__ = 'rib_service_pb2'
  # @@protoc_insertion_point(class_scope:routing.RouteUpdateRequest)
  ))
_sym_db.RegisterMessage(RouteUpdateRequest)

RouteRemoveRequest = _reflection.GeneratedProtocolMessageType('RouteRemoveRequest', (_message.Message,), dict(
  DESCRIPTOR = _ROUTEREMOVEREQUEST,
  __module__ = 'rib_service_pb2'
  # @@protoc_insertion_point(class_scope:routing.RouteRemoveRequest)
  ))
_sym_db.RegisterMessage(RouteRemoveRequest)

RouteGetRequest = _reflection.GeneratedProtocolMessageType('RouteGetRequest', (_message.Message,), dict(
  DESCRIPTOR = _ROUTEGETREQUEST,
  __module__ = 'rib_service_pb2'
  # @@protoc_insertion_point(class_scope:routing.RouteGetRequest)
  ))
_sym_db.RegisterMessage(RouteGetRequest)

RouteOperReply = _reflection.GeneratedProtocolMessageType('RouteOperReply', (_message.Message,), dict(
  DESCRIPTOR = _ROUTEOPERREPLY,
  __module__ = 'rib_service_pb2'
  # @@protoc_insertion_point(class_scope:routing.RouteOperReply)
  ))
_sym_db.RegisterMessage(RouteOperReply)

RouteGetReply = _reflection.GeneratedProtocolMessageType('RouteGetReply', (_message.Message,), dict(
  DESCRIPTOR = _ROUTEGETREPLY,
  __module__ = 'rib_service_pb2'
  # @@protoc_insertion_point(class_scope:routing.RouteGetReply)
  ))
_sym_db.RegisterMessage(RouteGetReply)


import grpc
from grpc.beta import implementations as beta_implementations
from grpc.beta import interfaces as beta_interfaces
from grpc.framework.common import cardinality
from grpc.framework.interfaces.face import utilities as face_utilities


class RibStub(object):

  def __init__(self, channel):
    """Constructor.

    Args:
      channel: A grpc.Channel.
    """
    self.RouteAdd = channel.unary_unary(
        '/routing.Rib/RouteAdd',
        request_serializer=RouteUpdateRequest.SerializeToString,
        response_deserializer=RouteOperReply.FromString,
        )
    self.RouteModify = channel.unary_unary(
        '/routing.Rib/RouteModify',
        request_serializer=RouteUpdateRequest.SerializeToString,
        response_deserializer=RouteOperReply.FromString,
        )
    self.RouteUpdate = channel.unary_unary(
        '/routing.Rib/RouteUpdate',
        request_serializer=RouteUpdateRequest.SerializeToString,
        response_deserializer=RouteOperReply.FromString,
        )
    self.RouteRemove = channel.unary_unary(
        '/routing.Rib/RouteRemove',
        request_serializer=RouteRemoveRequest.SerializeToString,
        response_deserializer=RouteOperReply.FromString,
        )
    self.RouteGet = channel.unary_stream(
        '/routing.Rib/RouteGet',
        request_serializer=RouteGetRequest.SerializeToString,
        response_deserializer=RouteGetReply.FromString,
        )


class RibServicer(object):

  def RouteAdd(self, request, context):
    """* Route Add operation

    Add a static route to the routing table.

    RouteAdd may be called multiple times for the same prefix to add
    multiple paths with distinct cookie for the same destination.
    If a matching route already exists in the given table, then an error
    will be returned.

    RoutingRouteOperRequest may contain from one to 1000 routes to be added.

    If the request contains multiple routes, the routes will
    be processed in the order given and the first error encountered will
    cause the request to abort.
    The API always returns the final status (success or first error
    encountered) and the number of routes that were successfully created
    prior to any error or full completion of the request.
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def RouteModify(self, request, context):
    """* Route Modify operation
    Modify an existing programmed static route in the routing table. For
    each route in the request, if the key is matched, the matched route will
    be updated with the supplied route attributes.

    If a matching route does not exist in the given table, then an error
    will be returned.

    RouteUpdateRequest may contain from one to 1000 routes to be added.
    If the request contains multiple routes, the routes will be processed
    in the order given and the first error encountered will cause the
    request to abort.
    The API always returns the final status (success or first error
    encountered) and the number of routes that were successfully modified
    prior to any error or full completion of the request.
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def RouteUpdate(self, request, context):
    """* Route Update operation
    Create a new static route if a matching route does not exist, OR
    modify an existing static route if it is already present in the
    routing table.
    RouteUpdateRequest may contain from one to 1000 routes to be added.
    If the request contains multiple routes, the routes will be processed
    in the order given and the first error encountered will cause the
    request to abort.
    The API always returns the final status (success or first error
    encountered) and the number of routes that were successfully modified
    prior to any error or full completion of the request.
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def RouteRemove(self, request, context):
    """* Route Remove operation

    Remove a static route from the routing table.
    RouteRemove may be called multiple times for the same prefix
    to remove multiple paths with distinct path_cookie for the same
    destination. (NOTE: cookie support not yet implemented)

    The request may contain from one to 1000 routes  to be removed.

    If the request contains multiple routes, the routes will
    be processed in the order given and the first error encountered will
    cause the request to abort.
    The API always returns the final status (success or first error
    encountered) and the number of routes that were successfully modified
    prior to any error or full completion of the request.
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')

  def RouteGet(self, request, context):
    """* Route Get operation
    Lookup a route from the routing table.
    All match parameters are optional.
    Match fields that are not specified or that
    may match more than one route (e.g. a less-specific destination
    prefix) may result in multiple routes being returned in the replies.

    Responses are bulked for performance and the client can specify
    maxmimum number of route entries that JUNOS can send in one response
    message using route_count field. JUNOS may chose to pack less
    number of entries than that client has specified.

    Multiple route entries matching matching a given route prefix
    may be be counted as one (if its last one in the response) and may
    result in exceeding the specified route count.

    Replies are streamed until all match routes have been sent. The
    client will receive a final null message once all routes have
    been received.
    The server's walk of search results is not atomic so route changes
    during streaming and consumption of replies may or may not be
    reflected in the results.
    See RouteGetReply.
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')


def add_RibServicer_to_server(servicer, server):
  rpc_method_handlers = {
      'RouteAdd': grpc.unary_unary_rpc_method_handler(
          servicer.RouteAdd,
          request_deserializer=RouteUpdateRequest.FromString,
          response_serializer=RouteOperReply.SerializeToString,
      ),
      'RouteModify': grpc.unary_unary_rpc_method_handler(
          servicer.RouteModify,
          request_deserializer=RouteUpdateRequest.FromString,
          response_serializer=RouteOperReply.SerializeToString,
      ),
      'RouteUpdate': grpc.unary_unary_rpc_method_handler(
          servicer.RouteUpdate,
          request_deserializer=RouteUpdateRequest.FromString,
          response_serializer=RouteOperReply.SerializeToString,
      ),
      'RouteRemove': grpc.unary_unary_rpc_method_handler(
          servicer.RouteRemove,
          request_deserializer=RouteRemoveRequest.FromString,
          response_serializer=RouteOperReply.SerializeToString,
      ),
      'RouteGet': grpc.unary_stream_rpc_method_handler(
          servicer.RouteGet,
          request_deserializer=RouteGetRequest.FromString,
          response_serializer=RouteGetReply.SerializeToString,
      ),
  }
  generic_handler = grpc.method_handlers_generic_handler(
      'routing.Rib', rpc_method_handlers)
  server.add_generic_rpc_handlers((generic_handler,))


class BetaRibServicer(object):
  def RouteAdd(self, request, context):
    """* Route Add operation

    Add a static route to the routing table.

    RouteAdd may be called multiple times for the same prefix to add
    multiple paths with distinct cookie for the same destination.
    If a matching route already exists in the given table, then an error
    will be returned.

    RoutingRouteOperRequest may contain from one to 1000 routes to be added.

    If the request contains multiple routes, the routes will
    be processed in the order given and the first error encountered will
    cause the request to abort.
    The API always returns the final status (success or first error
    encountered) and the number of routes that were successfully created
    prior to any error or full completion of the request.
    """
    context.code(beta_interfaces.StatusCode.UNIMPLEMENTED)
  def RouteModify(self, request, context):
    """* Route Modify operation
    Modify an existing programmed static route in the routing table. For
    each route in the request, if the key is matched, the matched route will
    be updated with the supplied route attributes.

    If a matching route does not exist in the given table, then an error
    will be returned.

    RouteUpdateRequest may contain from one to 1000 routes to be added.
    If the request contains multiple routes, the routes will be processed
    in the order given and the first error encountered will cause the
    request to abort.
    The API always returns the final status (success or first error
    encountered) and the number of routes that were successfully modified
    prior to any error or full completion of the request.
    """
    context.code(beta_interfaces.StatusCode.UNIMPLEMENTED)
  def RouteUpdate(self, request, context):
    """* Route Update operation
    Create a new static route if a matching route does not exist, OR
    modify an existing static route if it is already present in the
    routing table.
    RouteUpdateRequest may contain from one to 1000 routes to be added.
    If the request contains multiple routes, the routes will be processed
    in the order given and the first error encountered will cause the
    request to abort.
    The API always returns the final status (success or first error
    encountered) and the number of routes that were successfully modified
    prior to any error or full completion of the request.
    """
    context.code(beta_interfaces.StatusCode.UNIMPLEMENTED)
  def RouteRemove(self, request, context):
    """* Route Remove operation

    Remove a static route from the routing table.
    RouteRemove may be called multiple times for the same prefix
    to remove multiple paths with distinct path_cookie for the same
    destination. (NOTE: cookie support not yet implemented)

    The request may contain from one to 1000 routes  to be removed.

    If the request contains multiple routes, the routes will
    be processed in the order given and the first error encountered will
    cause the request to abort.
    The API always returns the final status (success or first error
    encountered) and the number of routes that were successfully modified
    prior to any error or full completion of the request.
    """
    context.code(beta_interfaces.StatusCode.UNIMPLEMENTED)
  def RouteGet(self, request, context):
    """* Route Get operation
    Lookup a route from the routing table.
    All match parameters are optional.
    Match fields that are not specified or that
    may match more than one route (e.g. a less-specific destination
    prefix) may result in multiple routes being returned in the replies.

    Responses are bulked for performance and the client can specify
    maxmimum number of route entries that JUNOS can send in one response
    message using route_count field. JUNOS may chose to pack less
    number of entries than that client has specified.

    Multiple route entries matching matching a given route prefix
    may be be counted as one (if its last one in the response) and may
    result in exceeding the specified route count.

    Replies are streamed until all match routes have been sent. The
    client will receive a final null message once all routes have
    been received.
    The server's walk of search results is not atomic so route changes
    during streaming and consumption of replies may or may not be
    reflected in the results.
    See RouteGetReply.
    """
    context.code(beta_interfaces.StatusCode.UNIMPLEMENTED)


class BetaRibStub(object):
  def RouteAdd(self, request, timeout, metadata=None, with_call=False, protocol_options=None):
    """* Route Add operation

    Add a static route to the routing table.

    RouteAdd may be called multiple times for the same prefix to add
    multiple paths with distinct cookie for the same destination.
    If a matching route already exists in the given table, then an error
    will be returned.

    RoutingRouteOperRequest may contain from one to 1000 routes to be added.

    If the request contains multiple routes, the routes will
    be processed in the order given and the first error encountered will
    cause the request to abort.
    The API always returns the final status (success or first error
    encountered) and the number of routes that were successfully created
    prior to any error or full completion of the request.
    """
    raise NotImplementedError()
  RouteAdd.future = None
  def RouteModify(self, request, timeout, metadata=None, with_call=False, protocol_options=None):
    """* Route Modify operation
    Modify an existing programmed static route in the routing table. For
    each route in the request, if the key is matched, the matched route will
    be updated with the supplied route attributes.

    If a matching route does not exist in the given table, then an error
    will be returned.

    RouteUpdateRequest may contain from one to 1000 routes to be added.
    If the request contains multiple routes, the routes will be processed
    in the order given and the first error encountered will cause the
    request to abort.
    The API always returns the final status (success or first error
    encountered) and the number of routes that were successfully modified
    prior to any error or full completion of the request.
    """
    raise NotImplementedError()
  RouteModify.future = None
  def RouteUpdate(self, request, timeout, metadata=None, with_call=False, protocol_options=None):
    """* Route Update operation
    Create a new static route if a matching route does not exist, OR
    modify an existing static route if it is already present in the
    routing table.
    RouteUpdateRequest may contain from one to 1000 routes to be added.
    If the request contains multiple routes, the routes will be processed
    in the order given and the first error encountered will cause the
    request to abort.
    The API always returns the final status (success or first error
    encountered) and the number of routes that were successfully modified
    prior to any error or full completion of the request.
    """
    raise NotImplementedError()
  RouteUpdate.future = None
  def RouteRemove(self, request, timeout, metadata=None, with_call=False, protocol_options=None):
    """* Route Remove operation

    Remove a static route from the routing table.
    RouteRemove may be called multiple times for the same prefix
    to remove multiple paths with distinct path_cookie for the same
    destination. (NOTE: cookie support not yet implemented)

    The request may contain from one to 1000 routes  to be removed.

    If the request contains multiple routes, the routes will
    be processed in the order given and the first error encountered will
    cause the request to abort.
    The API always returns the final status (success or first error
    encountered) and the number of routes that were successfully modified
    prior to any error or full completion of the request.
    """
    raise NotImplementedError()
  RouteRemove.future = None
  def RouteGet(self, request, timeout, metadata=None, with_call=False, protocol_options=None):
    """* Route Get operation
    Lookup a route from the routing table.
    All match parameters are optional.
    Match fields that are not specified or that
    may match more than one route (e.g. a less-specific destination
    prefix) may result in multiple routes being returned in the replies.

    Responses are bulked for performance and the client can specify
    maxmimum number of route entries that JUNOS can send in one response
    message using route_count field. JUNOS may chose to pack less
    number of entries than that client has specified.

    Multiple route entries matching matching a given route prefix
    may be be counted as one (if its last one in the response) and may
    result in exceeding the specified route count.

    Replies are streamed until all match routes have been sent. The
    client will receive a final null message once all routes have
    been received.
    The server's walk of search results is not atomic so route changes
    during streaming and consumption of replies may or may not be
    reflected in the results.
    See RouteGetReply.
    """
    raise NotImplementedError()


def beta_create_Rib_server(servicer, pool=None, pool_size=None, default_timeout=None, maximum_timeout=None):
  request_deserializers = {
    ('routing.Rib', 'RouteAdd'): RouteUpdateRequest.FromString,
    ('routing.Rib', 'RouteGet'): RouteGetRequest.FromString,
    ('routing.Rib', 'RouteModify'): RouteUpdateRequest.FromString,
    ('routing.Rib', 'RouteRemove'): RouteRemoveRequest.FromString,
    ('routing.Rib', 'RouteUpdate'): RouteUpdateRequest.FromString,
  }
  response_serializers = {
    ('routing.Rib', 'RouteAdd'): RouteOperReply.SerializeToString,
    ('routing.Rib', 'RouteGet'): RouteGetReply.SerializeToString,
    ('routing.Rib', 'RouteModify'): RouteOperReply.SerializeToString,
    ('routing.Rib', 'RouteRemove'): RouteOperReply.SerializeToString,
    ('routing.Rib', 'RouteUpdate'): RouteOperReply.SerializeToString,
  }
  method_implementations = {
    ('routing.Rib', 'RouteAdd'): face_utilities.unary_unary_inline(servicer.RouteAdd),
    ('routing.Rib', 'RouteGet'): face_utilities.unary_stream_inline(servicer.RouteGet),
    ('routing.Rib', 'RouteModify'): face_utilities.unary_unary_inline(servicer.RouteModify),
    ('routing.Rib', 'RouteRemove'): face_utilities.unary_unary_inline(servicer.RouteRemove),
    ('routing.Rib', 'RouteUpdate'): face_utilities.unary_unary_inline(servicer.RouteUpdate),
  }
  server_options = beta_implementations.server_options(request_deserializers=request_deserializers, response_serializers=response_serializers, thread_pool=pool, thread_pool_size=pool_size, default_timeout=default_timeout, maximum_timeout=maximum_timeout)
  return beta_implementations.server(method_implementations, options=server_options)


def beta_create_Rib_stub(channel, host=None, metadata_transformer=None, pool=None, pool_size=None):
  request_serializers = {
    ('routing.Rib', 'RouteAdd'): RouteUpdateRequest.SerializeToString,
    ('routing.Rib', 'RouteGet'): RouteGetRequest.SerializeToString,
    ('routing.Rib', 'RouteModify'): RouteUpdateRequest.SerializeToString,
    ('routing.Rib', 'RouteRemove'): RouteRemoveRequest.SerializeToString,
    ('routing.Rib', 'RouteUpdate'): RouteUpdateRequest.SerializeToString,
  }
  response_deserializers = {
    ('routing.Rib', 'RouteAdd'): RouteOperReply.FromString,
    ('routing.Rib', 'RouteGet'): RouteGetReply.FromString,
    ('routing.Rib', 'RouteModify'): RouteOperReply.FromString,
    ('routing.Rib', 'RouteRemove'): RouteOperReply.FromString,
    ('routing.Rib', 'RouteUpdate'): RouteOperReply.FromString,
  }
  cardinalities = {
    'RouteAdd': cardinality.Cardinality.UNARY_UNARY,
    'RouteGet': cardinality.Cardinality.UNARY_STREAM,
    'RouteModify': cardinality.Cardinality.UNARY_UNARY,
    'RouteRemove': cardinality.Cardinality.UNARY_UNARY,
    'RouteUpdate': cardinality.Cardinality.UNARY_UNARY,
  }
  stub_options = beta_implementations.stub_options(host=host, metadata_transformer=metadata_transformer, request_serializers=request_serializers, response_deserializers=response_deserializers, thread_pool=pool, thread_pool_size=pool_size)
  return beta_implementations.dynamic_stub(channel, 'routing.Rib', cardinalities, options=stub_options)
# @@protoc_insertion_point(module_scope)
